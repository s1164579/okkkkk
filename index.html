<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Loken's Balanced Magic Tree</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body { margin: 0; background: #000000; overflow: hidden; font-family: sans-serif; }
        
        .input_video {
            position: absolute; top: 10px; left: 10px;
            width: 160px; height: 120px; 
            border-radius: 10px; border: 3px solid #FFD700; 
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); 
            z-index: 100; transform: scaleX(-1);
            opacity: 1.0; object-fit: cover; display: none; 
        }

        #status {
            position: fixed; bottom: 30px; width: 100%; text-align: center;
            color: rgba(255, 240, 200, 1); font-size: 1.1rem; pointer-events: none;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
            font-weight: bold; z-index: 101;
        }

        #gesture-debug {
            position: absolute; top: 10px; right: 10px;
            color: #00ff00; font-family: monospace; font-size: 12px;
            background: rgba(0,0,0,0.6); padding: 5px;
            border-radius: 4px; pointer-events: none; text-align: right;
            z-index: 102;
        }

        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); 
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 999; transition: opacity 0.5s;
        }
        
        #start-btn {
            padding: 15px 40px; font-size: 1.2rem; color: #fff;
            background: linear-gradient(45deg, #D42426, #2E8B57);
            border: 2px solid #FFD700; border-radius: 50px;
            cursor: pointer; box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            margin-bottom: 10px;
        }
        .loading-text { color: #fff; font-size: 0.9rem; margin-top: 10px; text-shadow: 0 0 5px #000; }
    </style>
</head>
<body>

    <div id="overlay">
        <button id="start-btn">‚ö° ÂºÄÂêØ‰ªôÊ∞îÈ≠îÊ≥ï ‚ö°</button>
        <div class="loading-text" id="loading-msg">ËÉåÊôØ‰∏≠ÁöÑÊ†ëÂ∑≤ÁªèÂú®Á≠âÂæÖ‰Ω†‰∫Ü...</div>
    </div>

    <div id="status"></div>
    <div id="gesture-debug">Á≠âÂæÖÊëÑÂÉèÂ§¥ÂêØÂä®...</div>
    <video class="input_video" playsinline muted autoplay></video>

    <script type="module">
        let isExploded = true; 
        const SMOOTHNESS = 0.08; 
        let currentLerp = 1.0; 

        let scene, camera, renderer;
        let treeParticles, treeGeo, starParticles, starGeo, ribbonParticles, ribbonGeo;
        
        // ‰øùÊåÅÈ´òÂØÜÂ∫¶ÔºåÁ°Æ‰øùÊ∏ÖÊô∞Â∫¶
        const PARTICLE_COUNT = 28000; 
        const STAR_PARTICLE_COUNT = 1500; 
        const RIBBON_COUNT = 2000; 

        const treeTargets = new Float32Array(PARTICLE_COUNT * 3);
        const textTargets = new Float32Array(PARTICLE_COUNT * 3);
        const ribbonTreeTargets = new Float32Array(RIBBON_COUNT * 3);
        const ribbonRandomTargets = new Float32Array(RIBBON_COUNT * 3);

        const overlay = document.getElementById('overlay');
        const startBtn = document.getElementById('start-btn');
        const loadingMsg = document.getElementById('loading-msg');
        const videoElement = document.getElementsByClassName('input_video')[0];
        const statusElement = document.getElementById('status');
        const debugElement = document.getElementById('gesture-debug');

        function generateTextTargets() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const width = 1600; const height = 800;
            canvas.width = width; canvas.height = height;
            ctx.fillStyle = '#000000'; ctx.fillRect(0, 0, width, height);
            ctx.fillStyle = '#FFFFFF'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.font = '900 230px "Arial Black", sans-serif'; 
            ctx.fillText("Loken", width / 2, height / 2 - 110);
            ctx.font = 'bold 100px "Arial", sans-serif';
            ctx.fillText("Merry Christmas", width / 2, height / 2 + 80);
            const data = ctx.getImageData(0, 0, width, height).data;
            const validPoints = [];
            const step = 4; 
            for (let y = 0; y < height; y += step) {
                for (let x = 0; x < width; x += step) {
                    // ‰øùÊåÅËæÉ‰ΩéÁöÑÈòàÂÄºÔºåÊäìÂèñÊõ¥Â§öÁªÜËäÇ
                    if (data[(y * width + x) * 4] > 50) { 
                        validPoints.push((x - width / 2) * 0.045, -(y - height / 2) * 0.045 + 10, 0);
                    }
                }
            }
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                if (i < validPoints.length / 3) {
                    textTargets[i*3] = validPoints[i*3]; textTargets[i*3+1] = validPoints[i*3+1]; textTargets[i*3+2] = validPoints[i*3+2];
                } else {
                    const r = 50 + Math.random() * 30; const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
                    textTargets[i*3] = r * Math.sin(phi) * Math.cos(theta); textTargets[i*3+1] = r * Math.sin(phi) * Math.sin(theta); textTargets[i*3+2] = r * Math.cos(phi);
                }
            }
        }

        // ‚òÖ‚òÖ‚òÖ ‰ºòÂåñ1ÔºöÊüîÂåñÂÖâÊôïÁ∫πÁêÜÔºå‰∏≠ÂøÉ‰∏çÂÜçÊ≠ªÁôΩ ‚òÖ‚òÖ‚òÖ
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32; 
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            // Ê†∏ÂøÉÁ®çÂæÆÂ∏¶ÁÇπÈÄèÊòéÂ∫¶ÔºåËøáÊ∏°Êõ¥ÊüîÂíå
            grad.addColorStop(0.0, 'rgba(255, 255, 255, 0.9)'); 
            grad.addColorStop(0.4, 'rgba(255, 240, 200, 0.5)');
            grad.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.01); 
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 8, 45); camera.lookAt(0, 10, 0); 
            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            // ‚òÖ‚òÖ‚òÖ ‰ºòÂåñ2ÔºöÈôç‰ΩéÂÖ®Â±ÄÊõùÂÖâÔºåÈò≤Ê≠¢‰∫ÆÁûéÁúº ‚òÖ‚òÖ‚òÖ
            renderer.toneMappingExposure = 1.1; 
            document.body.appendChild(renderer.domElement);

            generateTextTargets();
            createTreeData(); createRibbonData();
            createParticles(); createRibbons(); createParticleStar();  

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            animate();
        }

        function createParticleStar() {
            starGeo = new THREE.BufferGeometry(); const positions = []; const colors = [];
            const cCore = new THREE.Color(0xFFFFFF); const cTip = new THREE.Color(0xFFD700);  
            const outerR = 1.6; const innerR = 0.6; const depth = 0.5;
            const baseVertices = [];
            for (let i = 0; i < 10; i++) {
                const r = (i % 2 === 0) ? outerR : innerR; const angle = i * (Math.PI * 2 / 10) - Math.PI / 2;
                baseVertices.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r, z: 0 });
            }
            const frontTip = { x: 0, y: 0, z: depth }; const backTip = { x: 0, y: 0, z: -depth }; const center = { x: 0, y: 0, z: 0 };
            for (let i = 0; i < STAR_PARTICLE_COUNT; i++) {
                const sector = Math.floor(Math.random() * 10);
                const pA = center; const pB = baseVertices[sector]; const pC = baseVertices[(sector + 1) % 10]; 
                const isFront = Math.random() > 0.5; const pApex = isFront ? frontTip : backTip;
                let s = Math.sqrt(Math.random()); let t = Math.random();
                let bx = (1-s) * pA.x + s * (1-t) * pB.x + s * t * pC.x; let by = (1-s) * pA.y + s * (1-t) * pB.y + s * t * pC.y; let bz = (1-s) * pA.z + s * (1-t) * pB.z + s * t * pC.z; 
                let h = 1 - Math.sqrt(Math.random()); 
                let x = bx + (pApex.x - bx) * h; let y = by + (pApex.y - by) * h; let z = bz + (pApex.z - bz) * h;
                positions.push(x, y, z);
                const dist = Math.sqrt(x*x + y*y + z*z); colors.push(cCore.clone().lerp(cTip, Math.min(1, dist/outerR)).r, cCore.clone().lerp(cTip, Math.min(1, dist/outerR)).g, cCore.clone().lerp(cTip, Math.min(1, dist/outerR)).b);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); starGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            // ÊòüÊòü‰πüÂêåÊ≠•Ë∞ÉÊüîÂíå
            starParticles = new THREE.Points(starGeo, new THREE.PointsMaterial({ size: 0.16, map: createGlowTexture(), vertexColors: true, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false }));
            starParticles.position.set(0, 21.6, 0); scene.add(starParticles);
        }
        function createTreeData() {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const h = Math.random() * 22; const rBase = (1 - h / 23) * 7.5 + Math.random() * 0.5; const angle = h * 5 + Math.random() * Math.PI * 2; 
                treeTargets[i*3] = Math.cos(angle) * rBase; treeTargets[i*3+1] = h - 2; treeTargets[i*3+2] = Math.sin(angle) * rBase;
            }
        }
        function createRibbonData() {
            for (let i = 0; i < RIBBON_COUNT; i++) {
                const h = (i / RIBBON_COUNT) * 22; const rBase = (1 - h / 23.5) * 8.5; const angle = h * 4 + Math.PI * 2; 
                ribbonTreeTargets[i*3] = Math.cos(angle) * rBase; ribbonTreeTargets[i*3+1] = h - 2; ribbonTreeTargets[i*3+2] = Math.sin(angle) * rBase;
                const r = 30 + Math.random() * 20; const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
                ribbonRandomTargets[i*3] = r * Math.sin(phi) * Math.cos(theta); ribbonRandomTargets[i*3+1] = r * Math.sin(phi) * Math.sin(theta); ribbonRandomTargets[i*3+2] = r * Math.cos(phi);
            }
        }
        function createParticles() {
            treeGeo = new THREE.BufferGeometry(); const positions = new Float32Array(PARTICLE_COUNT * 3); const colors = [];
            const c1 = new THREE.Color('#D42426'); const c2 = new THREE.Color('#2E8B57'); const c3 = new THREE.Color('#FFFFFF'); 
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                positions[i*3] = textTargets[i*3]; positions[i*3+1] = textTargets[i*3+1]; positions[i*3+2] = textTargets[i*3+2];
                let color; const rnd = Math.random(); 
                // Á®çÂæÆÂáèÂ∞ëÁôΩËâ≤Á≤íÂ≠êÁöÑÊØî‰æãÔºåÊÅ¢Â§çËâ≤ÂΩ©ÊÑü
                if(rnd < 0.35) color = c3; else if (rnd < 0.7) color = c2; else color = c1; colors.push(color.r, color.g, color.b);
            }
            treeGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3)); treeGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            // ‚òÖ‚òÖ‚òÖ ‰ºòÂåñ3ÔºöÊ†∏ÂøÉË∞ÉÊï¥ÔºÅÈôç‰ΩéÈÄèÊòéÂ∫¶ÂíåÂ∞∫ÂØ∏ÔºåÂÆûÁé∞Âπ≥Ë°° ‚òÖ‚òÖ‚òÖ
            const mat = new THREE.PointsMaterial({ 
                size: 0.28, // ‰ªé 0.38 ÈôçÂà∞ 0.28ÔºåÂèòÁ≤æËá¥
                map: createGlowTexture(), 
                vertexColors: true, 
                transparent: true, 
                opacity: 0.75, // ‰ªé 1.0 ÈôçÂà∞ 0.75ÔºåÊÅ¢Â§ç‰ªôÊ∞î
                blending: THREE.AdditiveBlending, 
                depthWrite: false 
            });
            treeParticles = new THREE.Points(treeGeo, mat);
            scene.add(treeParticles);
        }
        function createRibbons() {
            ribbonGeo = new THREE.BufferGeometry(); const positions = new Float32Array(RIBBON_COUNT * 3); const colors = [];
            for(let i=0; i<RIBBON_COUNT; i++){ positions[i*3] = ribbonRandomTargets[i*3]; positions[i*3+1] = ribbonRandomTargets[i*3+1]; positions[i*3+2] = ribbonRandomTargets[i*3+2]; colors.push(1.0, 0.85, 0.5); }
            ribbonGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3)); ribbonGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            // ‰∏ùÂ∏¶‰πüÂêåÊ≠•Ë∞ÉÊüîÂíå
            ribbonParticles = new THREE.Points(ribbonGeo, new THREE.PointsMaterial({ size: 0.22, map: createGlowTexture(), vertexColors: true, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending, depthWrite: false }));
            scene.add(ribbonParticles);
        }

        function animate() {
            requestAnimationFrame(animate);
            const targetLerp = isExploded ? 1.0 : 0.0;
            currentLerp += (targetLerp - currentLerp) * SMOOTHNESS;

            const treePos = treeGeo.attributes.position.array;
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                treePos[i] = treeTargets[i] * (1 - currentLerp) + textTargets[i] * currentLerp;
                treePos[i+1] = treeTargets[i+1] * (1 - currentLerp) + textTargets[i+1] * currentLerp;
                treePos[i+2] = treeTargets[i+2] * (1 - currentLerp) + textTargets[i+2] * currentLerp;
            }
            treeGeo.attributes.position.needsUpdate = true;

            const ribbonPos = ribbonGeo.attributes.position.array;
            for (let i = 0; i < RIBBON_COUNT * 3; i++) {
                ribbonPos[i] = ribbonTreeTargets[i] * (1 - currentLerp) + ribbonRandomTargets[i] * currentLerp;
                ribbonPos[i+1] = ribbonTreeTargets[i+1] * (1 - currentLerp) + ribbonRandomTargets[i+1] * currentLerp;
                ribbonPos[i+2] = ribbonTreeTargets[i+2] * (1 - currentLerp) + ribbonRandomTargets[i+2] * currentLerp;
            }
            ribbonGeo.attributes.position.needsUpdate = true;

            const rotSpeed = 0.003 * (1 - currentLerp);
            treeParticles.rotation.y += rotSpeed;
            ribbonParticles.rotation.y += rotSpeed;
            if (starParticles) {
                starParticles.rotation.y -= 0.02; 
                const pulse = 1 + Math.sin(Date.now() * 0.003) * 0.05;
                const scale = Math.max(0.01, (1 - currentLerp) * pulse);
                starParticles.scale.set(scale, scale, scale);
                starParticles.material.opacity = Math.max(0, (1 - currentLerp * 1.5) * 0.9);
                starParticles.position.y = 21.6 + Math.sin(Date.now() * 0.002) * 0.3;
            }
            renderer.render(scene, camera);
        }

        function dist(p1, p2) { return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)); }

        function onResults(results) {
            if (overlay.style.opacity !== '0') {
                overlay.style.opacity = '0';
                setTimeout(() => { overlay.style.display = 'none'; }, 500);
                statusElement.innerHTML = "‚ú® È≠îÊ≥ïÂ∑≤ÂêØÂä® ‚ú®<br>üñê Âº†ÂºÄ = ÂêçÂ≠ó | ‚úä Êè°Êã≥ = Âú£ËØûÊ†ë";
                videoElement.style.display = 'block'; 
            }
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];
                const wrist = hand[0]; const middleMCP = hand[9];
                const palmSize = dist(wrist, middleMCP);
                const tips = [4, 8, 12, 16, 20];
                let totalTipDist = 0;
                tips.forEach(idx => { totalTipDist += dist(wrist, hand[idx]); });
                const ratio = (totalTipDist / 5) / palmSize;
                debugElement.innerHTML = `Áä∂ÊÄÅ: ${isExploded ? 'Âº†ÂºÄ' : 'Êè°Êã≥'}`;
                if (ratio > 1.4) isExploded = true; else if (ratio < 1.1) isExploded = false;
            }
        }

        initThree();

        startBtn.addEventListener('click', () => {
            loadingMsg.innerText = "Ê≠£Âú®Âä†ËΩΩ AI ËßÜËßâÊ®°ÂûãÔºåËØ∑Á®çÂÄô...";
            startBtn.disabled = true; startBtn.style.opacity = 0.5;
            const hands = new Hands({locateFile: (file) => { return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`; }});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onResults);
            const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 640, height: 480 });
            cameraUtils.start().catch(err => { loadingMsg.innerText = "ÈîôËØØ: " + err; loadingMsg.style.color = "red"; });
        });

    </script>
</body>
</html>